---
title: 浮点数探秘
tags:
  - 码海拾贝
categories:
  - 代码沉思录
date: 2021-09-25 21:06:03
mathjax: true
---

## 引子

考虑如下代码：

```java
public static void main(String[] args) {
    floatPrintTest(10000000, 10001000, 10);
    floatPrintTest(100000000, 100001000, 10);

    // 程序会陷入死循环
    // floatPrintTest(1000000000, 1000001000, 10);
}

public static void floatPrintTest(float start, float stop, float step) {
    int count = 0;
    float distance = stop - start;
    while (start < stop) {
        count++;
        start = start + step;
    }
    System.out.println(distance + "除以" + step + "等于" + count);
}
```

程序的输出如下：
```text
1000.0除以10.0等于100
1000.0除以10.0等于125
```

同样的步进精度，同样需要步进1000个数，为什么当浮点数的位数发生变化后，输出的结果却迥然不同呢？这个就涉及到了float的值到底是怎么表达的问题了，也就是[IEEE 754二进制浮点数算术标准](https://zh.wikipedia.org/zh-cn/IEEE_754)，接下来我们就仔细探究一下float背后隐含的秘密。

<!-- more --> 

## 浮点数剖析

根据IEEE 754的定义，一个浮点数的可以使用如下公式进行表示：

\begin{equation}
value=sign\times exponent\times fraction
\end{equation}

也就是说，**浮点数的值**等于**符号位**（sign bit）乘以**指数偏移值**（exponent bias）再乘以**分数值**（fraction）

从二进制角度上看，一个float在存储的时候由如下三部分组成：

\begin{equation}
\underbrace{sign} \mid \underbrace{exponent} \mid \underbrace{fraction}
\end{equation}

以java中使用的单精度浮点数为例，其中符号位占据1位，指数偏移值占据8位，分数值占据23位，总共32位。

说了这么多理论上的东西，那么到底一个浮点数的值是怎么计算出来的呢？

## 单精度浮点数的计算

前面我们介绍了浮点数的表示公式和浮点数的组成，那么，一个浮点数到底应该怎么计算呢？我们先给出浮点数的计算公式：

\begin{cases}
 & float=-1^S\times 2^E\times (1+M)\mid { 当 } E\neq 0 （1）\\\\ 
 & float=-1^S\times 2^E\times M\mid  { 当 } E=0且M\neq 0（2）
\end{cases}

其中：S为符号位取值，E为根据指数偏移值计算出来的值，M为根据分数值计算出来的小数。

**E的计算：**

我们知道，指数偏移值一共有8位，将其转换成10进制，则其表示范围为0~255。当指数偏移值为全0或全1时，浮点数计算有特殊处理（后面会介绍），因此实际可用取值范围应为1~254。

注意到表达式（1），这其中除了$2^E$之外，没有哪个部分能够表示小数，而浮点数是可以表示小数的，因此，$2^E$必须能够表达小数，即E必须有符号，所以指数偏移值在计算E时，必须有一个偏移。IEEE 754规定这个偏移值为$2^8-1=127$，也就是说，E的取值范围应该是-126~127，即为指数偏移值的计算值-127（指数偏移值不能为全0或全1）。

读者可能注意到了，在计算浮点数时，分数值所表示的部分是不确定的：它由分数值和指数偏移值共同决定。一般地，我们将（1）对应的浮点数称为规约形式的浮点数，（2）对应的浮点数称为非规约形式的浮点数。非规约形式的浮点数主要是为了用于表示部分接近0的浮点数以及一些特殊的值。

下表给出了单精度浮点数的各种极值情况（包括特殊值）：

|类别|正负号|实际指数|指数偏移值|指数域|尾数域|数值|
|-|-|-|-|-|-|-|
|正零|0|-127|0|0000 0000|000 0000 0000 0000 0000 0000|0.0|
|负零|1|-127|0|0000 0000|000 0000 0000 0000 0000 0000|-0.0|
|1|0|0|127|0111 1111|000 0000 0000 0000 0000 0000|1.0|
|-1|1|0|127|0111 1111|000 0000 0000 0000 0000 0000|-1.0|
|最小非规约数|*|-126|0|0000 0000|000 0000 0000 0000 0000 0001|$\pm 2^{-23}\times 2^{-126}=\pm 2^{-149} \approx \pm 1.4\times 10^{-45}$|
|中间大小的非规约数|*|-126|0|0000 0000|100 0000 0000 0000 0000 0000|$\pm 2^{-1}\times 2^{-126}=\pm 2^{-127} \approx \pm 5.88\times 10^{-39}$|
|最大的非规约数|*|-126|0|0000 0000|111 1111 1111 1111 1111 1111|$\pm (1-2^{-23})\times 2^{-126}\approx \pm 1.18\times 10^{-38}$|
|最小的规约数|*|-126|1|0000 0001|000 0000 0000 0000 0000 0000|$\pm 2^{-126}\approx \pm 1.18\times 10^{-38}$|
|最大的规约数|*|127|254|1111 1110|111 1111 1111 1111 1111 1111|$\pm (2-2^{-23})\times 2^{127}\approx \pm 3.4\times10^{38}$|
|正无穷|0|128|255|1111 1111|000 0000 0000 0000 0000 0000|$+\infty$|
|负无穷|1|128|255|1111 1111|000 0000 0000 0000 0000 0000|$-\infty$|
|NaN|*|128|255|1111 1111|非全0|NaN|

对于双精度浮点数，上面的规则同样适用，只是指数偏移值的长度为11位，分数值的长度为52位而已。

## 单精度浮点数的精确性

从前面的计算公式我们可以看出，在表示大整数时，浮点数实际上是有最小步进精度的，这个最小步进精度由等式中的小数部分，即M决定。我们知道，浮点数的小数部分是根据分数值计算出来的，其最小步进精度为$2^{-23}$，那么，浮点数的最小步进数为$minStep=2^{-23}\times 2^E$，这也就意味着，当$E\leqslant 23$时，浮点数可以保证每次步进的值小于等于1，即可以保证整数级别的精确性，一旦$E> 23$，那么就无法保证整数级别的精确性。由于$2^{-23}\approx 1.19\times 10^{-7}$，我们也可以粗略地说，当大整数的整数部分小于等于7位时，浮点数可以保证整数部分的精确性，这也就是为什么引言中的代码仅仅浮点数的位数发生变化后，输出的结果迥然不同的原因。

有的读者可能会说，引言中第一个例子的整数部分有8位，为什么计算结果还是正确的呢？这个实际上就是进制转换的锅了，从上面推算精度的过程中可以看出，决定是否能够保证整数级别的精度的，其实是E是否大于23，例1中的变量`start`取值为1000000，其浮点数的计算公式为$10000000\approx 1\times 2^{23}\times 1.019209289$，E的取值等于23，所以能够保证精度。接下来我们改变一下E，验证一下我们的猜想。

```java
public static void main(String[] args) {
    // 2^24 = 16777216，步进精度为2
    System.out.println("E=23，步进精度为1");
    floatPrintTest(16700000, 16700120, 1);
    floatPrintTest(16700000, 16700120, 2);
    floatPrintTest(16700000, 16700120, 3);
    floatPrintTest(16700000, 16700120, 6);
    System.out.println("\r\nE=24，步进精度为2");

    // 程序会陷入死循环
    // floatPrintTest(33000000, 33000120, 1);
    floatPrintTest(33000000, 33000120, 2);
    floatPrintTest(33000000, 33000120, 3);
    floatPrintTest(33000000, 33000120, 6);

    // 2^25 = 33554432，步进精度为4
    System.out.println("\r\nE=25，步进精度为4");

    // 程序会陷入死循环
    // floatPrintTest(34000000, 34000120, 1);
    // floatPrintTest(34000000, 34000120, 2);
    floatPrintTest(34000000, 34000120, 3);
    floatPrintTest(34000000, 34000120, 6);
}

public static void floatPrintTest(float start, float stop, float step) {
    int count = 0;
    float distance = stop - start;
    while (start < stop) {
        count++;
        start = start + step;
    }
    System.out.println(distance + "除以" + step + "等于" + count);
}
```

程序的输出结果为：

```text
E=23，步进精度为1
120.0除以1.0等于120
120.0除以2.0等于60
120.0除以3.0等于40
120.0除以6.0等于20

E=24，步进精度为2
120.0除以2.0等于60
120.0除以3.0等于30
120.0除以6.0等于20

E=25，步进精度为4
120.0除以3.0等于30
120.0除以6.0等于15
```

从输出结果就可以看出来，当E改变时，由于步进精度的改变，计算出来的结果也会发生改变。